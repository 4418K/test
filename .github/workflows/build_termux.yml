name: Build for Termux (Custom ELF)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  build_android_custom_elf:
    runs-on: ubuntu-latest
    name: Build ELF with C-Bootstrap
    steps:
      - uses: actions/checkout@v4

      - name: Build inside Aarch64 Alpine container
        uses: uraimo/run-on-arch-action@v2
        with:
          arch: aarch64
          distro: alpine_latest
          githubToken: ${{ github.token }}
          
          run: |
            echo "ğŸ”¥ 1. Installing dependencies..."
            apk update
            # åªéœ€è¦æœ€åŸºç¡€çš„å·¥å…·ï¼šPython, GCC, Tar
            apk add --no-cache python3 python3-dev py3-pip gcc musl-dev make build-base tar

            echo "ğŸ“¦ 2. Installing Nuitka..."
            pip3 install nuitka --break-system-packages

            echo "ğŸš€ 3. Nuitka Compilation..."
            # ç”Ÿæˆ standalone æ–‡ä»¶å¤¹
            python3 -m nuitka --standalone --output-dir=build_out main.py

            echo "ğŸ“¦ 4. Packing Payload..."
            cd build_out
            # æŠŠ Nuitka ç”Ÿæˆçš„æ–‡ä»¶å¤¹æ‰“åŒ…æˆ payload.tar.gz
            tar -czf payload.tar.gz main.dist

            echo "ğŸ› ï¸ 5. Creating C Launcher Source..."
            # ç¼–å†™ä¸€ä¸ªå¾®å‹çš„ C è¯­è¨€å¯åŠ¨å™¨
            # è¿™ä¸ªç¨‹åºä¼šè¯»å–é™„åŠ åœ¨è‡ªèº«æœ«å°¾çš„å‹ç¼©åŒ…æ•°æ®
            cat > launcher.c << 'EOF'
            #include <stdio.h>
            #include <stdlib.h>
            #include <string.h>
            #include <unistd.h>
            #include <sys/stat.h>
            #include <sys/types.h>

            #define MARKER "PAYLOAD_START_HERE_XYZ"
            #define MARKER_LEN 22

            int main(int argc, char *argv[]) {
                FILE *self = fopen("/proc/self/exe", "rb");
                if (!self) return 1;

                // 1. å¯»æ‰¾ Payload æ ‡è®°
                // ä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä»¬ç›´æ¥æœç´¢æ ‡è®°å­—ç¬¦ä¸²
                // åœ¨å¤§æ–‡ä»¶ä¸­è¿™å¯èƒ½ç¨æ…¢ï¼Œä½†å¯¹äºè¿™ä¸ªç”¨é€”è¶³å¤Ÿå¿«
                unsigned char buffer[4096];
                long payload_offset = -1;
                size_t bytes_read;
                
                while ((bytes_read = fread(buffer, 1, sizeof(buffer), self)) > 0) {
                    for (size_t i = 0; i < bytes_read - MARKER_LEN; i++) {
                        if (memcmp(buffer + i, MARKER, MARKER_LEN) == 0) {
                            payload_offset = ftell(self) - bytes_read + i + MARKER_LEN;
                            goto found;
                        }
                    }
                    // å›é€€ä¸€ç‚¹ï¼Œé˜²æ­¢æ ‡è®°è·¨è¶Šç¼“å†²åŒºè¾¹ç•Œ
                    fseek(self, -MARKER_LEN, SEEK_CUR);
                }

            found:
                if (payload_offset == -1) {
                    fprintf(stderr, "Error: Corrupted binary (Payload not found).\n");
                    fclose(self);
                    return 1;
                }

                // 2. åˆ›å»ºä¸´æ—¶ç›®å½•
                char tmp_dir[] = "/data/data/com.termux/files/usr/tmp/app_XXXXXX";
                // å¦‚æœæ˜¯åœ¨æ™®é€š Linux ä¸Šï¼Œå›é€€åˆ° /tmp
                if (access("/data/data/com.termux/files/usr/tmp", F_OK) != 0) {
                    strcpy(tmp_dir, "/tmp/app_XXXXXX");
                }
                
                if (!mkdtemp(tmp_dir)) {
                    perror("Failed to create temp dir");
                    return 1;
                }

                // 3. æå– Payload
                char tar_cmd[1024];
                // ç§»åŠ¨æ–‡ä»¶æŒ‡é’ˆåˆ° payload å¼€å§‹å¤„
                fseek(self, payload_offset, SEEK_SET);
                
                // å°† tar.gz å†™å‡ºåˆ°ä¸´æ—¶æ–‡ä»¶
                char tar_path[512];
                sprintf(tar_path, "%s/payload.tar.gz", tmp_dir);
                FILE *out_tar = fopen(tar_path, "wb");
                
                while ((bytes_read = fread(buffer, 1, sizeof(buffer), self)) > 0) {
                    fwrite(buffer, 1, bytes_read, out_tar);
                }
                fclose(out_tar);
                fclose(self);

                // 4. è§£å‹
                sprintf(tar_cmd, "tar -xf %s -C %s", tar_path, tmp_dir);
                system(tar_cmd);

                // 5. è¿è¡Œ
                // æ„å»ºå¯åŠ¨å‘½ä»¤ï¼Œä¼ é€’æ‰€æœ‰å‚æ•°
                char run_cmd[2048];
                sprintf(run_cmd, "%s/main.dist/main.bin", tmp_dir);
                
                // ç®€å•çš„å‚æ•°ä¼ é€’ (execv éœ€è¦æ•°ç»„ï¼Œè¿™é‡Œä¸ºäº†ç®€åŒ–ä½¿ç”¨ system æˆ–è€…æ˜¯æ„å»ºå­—ç¬¦ä¸²)
                // ä¸ºäº†æ­£ç¡®å¤„ç†ç©ºæ ¼ï¼Œè¿™é‡Œåšç®€å•æ‹¼æ¥ï¼Œç”Ÿäº§ç¯å¢ƒå»ºè®®ç”¨ execv
                for (int i = 1; i < argc; i++) {
                    strcat(run_cmd, " \"");
                    strcat(run_cmd, argv[i]);
                    strcat(run_cmd, "\"");
                }

                int ret = system(run_cmd);

                // 6. æ¸…ç†
                char rm_cmd[1024];
                sprintf(rm_cmd, "rm -rf %s", tmp_dir);
                system(rm_cmd);

                return WEXITSTATUS(ret);
            }
            EOF

            echo "ğŸ”¨ 6. Compiling Launcher..."
            # ç¼–è¯‘è¿™ä¸ª C ç¨‹åºï¼Œå®ƒæ˜¯é™æ€çš„ï¼Œå¾ˆå°ï¼Œä¸ä¼šå¯¼è‡´ QEMU å´©æºƒ
            gcc -static -O2 -o final_app launcher.c
            # å‰¥ç¦»ç¬¦å·ï¼Œå‡å°ä½“ç§¯ï¼Œå¢åŠ é€†å‘éš¾åº¦
            strip final_app

            echo "ğŸ”— 7. Attaching Payload..."
            # å†™å…¥æ ‡è®°
            echo -n "PAYLOAD_START_HERE_XYZ" >> final_app
            # è¿½åŠ å‹ç¼©åŒ…
            cat payload.tar.gz >> final_app

            echo "âœ… Build finished."
            ls -lh final_app
            file final_app

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: termux_aarch64_custom_elf
          path: build_out/final_app
