name: Build for Termux (Custom ELF Fixed)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  build_android_custom_elf:
    runs-on: ubuntu-latest
    name: Build ELF with C-Bootstrap
    steps:
      - uses: actions/checkout@v4

      - name: Build inside Aarch64 Alpine container
        uses: uraimo/run-on-arch-action@v2
        with:
          arch: aarch64
          distro: alpine_latest
          githubToken: ${{ github.token }}
          
          run: |
            echo "ğŸ”¥ 1. Installing dependencies..."
            apk update
            # ã€ä¿®å¤ç‚¹ã€‘è¿™é‡ŒåŠ ä¸Šäº† patchelf
            # Nuitka standalone æ¨¡å¼å¿…é¡»è¦æœ‰ patchelf æ‰èƒ½æ‰“åŒ… .so æ–‡ä»¶
            apk add --no-cache python3 python3-dev py3-pip gcc musl-dev make build-base tar patchelf

            echo "ğŸ“¦ 2. Installing Nuitka..."
            pip3 install nuitka --break-system-packages

            echo "ğŸš€ 3. Nuitka Compilation..."
            # ç”Ÿæˆ standalone æ–‡ä»¶å¤¹
            # æ­¤æ—¶æºä»£ç å·²è¢«ç¼–è¯‘ä¸ºäºŒè¿›åˆ¶ .so æ–‡ä»¶ï¼Œå®Œå…¨ä¸å¯è¯»
            python3 -m nuitka --standalone --output-dir=build_out pppppp.py

            echo "ğŸ“¦ 4. Packing Payload..."
            cd build_out
            # æŠŠ Nuitka ç”Ÿæˆçš„æ–‡ä»¶å¤¹æ‰“åŒ…æˆ payload.tar.gz
            # æ’é™¤å¯èƒ½å­˜åœ¨çš„ç¼“å­˜æ–‡ä»¶
            tar --exclude='__pycache__' -czf payload.tar.gz main.dist

            echo "ğŸ› ï¸ 5. Creating C Launcher Source..."
            # ç¼–å†™ C è¯­è¨€å¯åŠ¨å™¨
            # å®ƒè´Ÿè´£å°†è‡ªèº«çš„ payload è§£å‹åˆ° Termux ä¸´æ—¶ç›®å½•å¹¶è¿è¡Œ
            cat > launcher.c << 'EOF'
            #include <stdio.h>
            #include <stdlib.h>
            #include <string.h>
            #include <unistd.h>
            #include <sys/stat.h>
            #include <sys/types.h>
            #include <libgen.h>

            #define MARKER "PAYLOAD_START_HERE_XYZ"
            #define MARKER_LEN 22

            int main(int argc, char *argv[]) {
                // æ‰“å¼€è‡ªèº«æ–‡ä»¶
                FILE *self = fopen("/proc/self/exe", "rb");
                if (!self) {
                    // å¦‚æœ /proc/self/exe å¤±è´¥ï¼ˆæå°‘è§ï¼‰ï¼Œå°è¯•ç”¨ argv[0]
                    self = fopen(argv[0], "rb");
                    if (!self) return 1;
                }

                // 1. å¯»æ‰¾ Payload æ ‡è®°
                unsigned char buffer[4096];
                long payload_offset = -1;
                size_t bytes_read;
                
                // ç®€å•çš„æœç´¢ç®—æ³•
                while ((bytes_read = fread(buffer, 1, sizeof(buffer), self)) > 0) {
                    for (size_t i = 0; i < bytes_read - MARKER_LEN; i++) {
                        if (memcmp(buffer + i, MARKER, MARKER_LEN) == 0) {
                            payload_offset = ftell(self) - bytes_read + i + MARKER_LEN;
                            goto found;
                        }
                    }
                    fseek(self, -MARKER_LEN, SEEK_CUR);
                }

            found:
                if (payload_offset == -1) {
                    fprintf(stderr, "Error: Corrupted binary (Payload not found).\n");
                    fclose(self);
                    return 1;
                }

                // 2. ç¡®å®šä¸´æ—¶ç›®å½•è·¯å¾„
                // ä¼˜å…ˆä½¿ç”¨ Termux çš„æ ‡å‡†ç¼“å­˜ç›®å½•ï¼Œä¿è¯æƒé™æ­£ç¡®
                char tmp_dir_template[] = "/data/data/com.termux/files/usr/tmp/app_XXXXXX";
                // ç®€å•çš„ fallback æ£€æµ‹
                struct stat st;
                if (stat("/data/data/com.termux/files/usr/tmp", &st) == -1) {
                    // å¦‚æœä¸æ˜¯ Termux ç¯å¢ƒï¼Œå›é€€åˆ° /tmp
                    strcpy(tmp_dir_template, "/tmp/app_XXXXXX");
                }
                
                char *tmp_path = mkdtemp(tmp_dir_template);
                if (!tmp_path) {
                    perror("Failed to create temp dir");
                    return 1;
                }

                // 3. æå–å‹ç¼©åŒ…
                fseek(self, payload_offset, SEEK_SET);
                
                char tar_path[1024];
                snprintf(tar_path, sizeof(tar_path), "%s/payload.tar.gz", tmp_path);
                
                FILE *out_tar = fopen(tar_path, "wb");
                if (!out_tar) return 1;
                
                while ((bytes_read = fread(buffer, 1, sizeof(buffer), self)) > 0) {
                    fwrite(buffer, 1, bytes_read, out_tar);
                }
                fclose(out_tar);
                fclose(self);

                // 4. è§£å‹
                char cmd[2048];
                snprintf(cmd, sizeof(cmd), "tar -xf \"%s\" -C \"%s\"", tar_path, tmp_path);
                if (system(cmd) != 0) return 1;

                // 5. è¿è¡Œå®é™…ç¨‹åº
                // Nuitka ç”Ÿæˆçš„ä¸»ç¨‹åºé€šå¸¸åœ¨ main.dist/main.bin
                char run_path[1024];
                snprintf(run_path, sizeof(run_path), "%s/main.dist/main.bin", tmp_path);
                
                // æ„å»ºè¿è¡Œå‘½ä»¤ï¼Œä¼ é€’æ‰€æœ‰å‚æ•°
                // æ³¨æ„ï¼šè¿™é‡Œä¸ºäº†å®‰å…¨ä½¿ç”¨äº†ç®€å•çš„å‘½ä»¤æ‹¼æ¥ï¼Œç”Ÿäº§ç¯å¢ƒå¯ä»¥è€ƒè™‘ fork+execv
                char full_cmd[4096];
                snprintf(full_cmd, sizeof(full_cmd), "\"%s\"", run_path);
                
                for (int i = 1; i < argc; i++) {
                    strcat(full_cmd, " \"");
                    strcat(full_cmd, argv[i]);
                    strcat(full_cmd, "\"");
                }

                int ret_code = system(full_cmd);

                // 6. æ¸…ç†ä¸´æ—¶æ–‡ä»¶ (å¯é€‰ï¼Œå¦‚æœä½ æƒ³ä¿ç•™ç¼“å­˜å¯ä»¥æ³¨é‡Šæ‰)
                snprintf(cmd, sizeof(cmd), "rm -rf \"%s\"", tmp_path);
                system(cmd);

                // è¿”å›å­ç¨‹åºçš„é€€å‡ºç 
                return WEXITSTATUS(ret_code);
            }
            EOF

            echo "ğŸ”¨ 6. Compiling Launcher..."
            # é™æ€ç¼–è¯‘ C å¯åŠ¨å™¨
            gcc -static -O2 -o final_app launcher.c
            strip final_app

            echo "ğŸ”— 7. Attaching Payload..."
            # å†™å…¥æ ‡è®°å’Œæ•°æ®
            echo -n "PAYLOAD_START_HERE_XYZ" >> final_app
            cat payload.tar.gz >> final_app

            echo "âœ… Build finished."
            ls -lh final_app
            file final_app

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: termux_aarch64_custom_elf_fixed
          path: build_out/final_app
